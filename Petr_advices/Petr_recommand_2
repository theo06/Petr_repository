Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option
is used, the command refuses to update a remote ref whose current value does not match what is expected.
This flag disables these checks, and can cause the remote repository to lose commits; use it with care.
Note that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations
configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart).
To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the
<refspec>...  section above for details.
[16:03:40] Peter Nechaev: When you want to delete history and by that have bad refs, you have to force it


by bad refs I mean, when you mess with your branch and now it's impossible to merge because it references on different place or time.

Anyway. Just reset commits and do push -f
[16:08:54] jose dim1: ok
[16:09:14] Peter Nechaev: this you won't need to commit
[16:09:24] Peter Nechaev: it's not reverting changes, it's just deleting history
[16:09:38] Peter Nechaev: You should never do this btw
[16:09:56] jose dim1: ok i will ask you first before doing a push --force
[16:10:07] Peter Nechaev: every time youwant to discard changes, revert them and commit, so everybody know.
[16:10:14] Peter Nechaev: *knows
[16:10:20] Peter Nechaev: but now it's okay

I'm not sure if you can put gitignore in home directory. It may be in $HOME/.config/git/ignore.
[16:21:01] Peter Nechaev: but I suggest you to put it in repo
[16:21:45] Peter Nechaev: and commit. Because you don't want other people to screw your repo

 what do you mean by people screwing my repo?
[16:52:53] Peter Nechaev: when you work together on the same project, you need to share your repo, right?
[16:53:02] jose dim1: yes
[16:53:04] Peter Nechaev: well, other guys may not have gitignore
[16:53:40] Peter Nechaev: and they may accidentally push binaries into it
[16:53:48] Peter Nechaev: and you'll have to revert them
[16:54:39] Peter Nechaev: that's why it's always a good idea to place a gitignore file in your repo
[16:54:47] Peter Nechaev: make it public
[16:55:10] jose dim1: ok
[16:55:19] Peter Nechaev: and put some files, specific your project, that you want to ignore
[16:55:35] Peter Nechaev: like log files and stuff
[16:55:52] jose dim1: git revert <this_commit> undoes all the changes made by this_commit?
[16:56:08] jose dim1: in the project commit's history?
[16:56:17] Peter Nechaev: yes, but it keeps the files
[16:56:29] Peter Nechaev: so you just change them, do commit -c and push
[16:57:43] jose dim1: if this_commit added a file, then git revert this commit will remove this file?
[17:02:13] Peter Nechaev: DESCRIPTION:
Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your
working tree to be clean (no modifications from the HEAD commit).
Note: git revert is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all
uncommitted changes in your working directory, you should see git-reset(1), particularly the --hard option. If you want to extract specific files as they
were in another commit, you should see git-checkout(1), specifically the git checkout <commit> -- <filename> syntax. Take care with these alternatives as
both will discard uncommitted changes in your working directory.
[17:02:31] Peter Nechaev: man git revert
[17:35:06] jose dim1: do you often use rebase?
[17:39:55] Peter Nechaev: can't remember the last time
[17:40:05] Peter Nechaev: about 3 years ago
[17:40:24] jose dim1: lol ok. they say it is usefull to have linear line of development.
[17:41:12] Peter Nechaev: I just create new branch for my something-something, then merge it with master
[17:41:44] Peter Nechaev: i mean
[17:41:53] jose dim1: from what I read, in public repo. (i.e. working with other people) it is forbidden to rebase, reset commits and amending commits.
[17:41:58] Peter Nechaev: i don't use rebase, because I always merge changes from master
[17:42:07] jose dim1: ok
[17:42:11] Peter Nechaev: and apply them at the end
[17:42:39] Peter Nechaev: yes, that's a good practice
[17:42:55] jose dim1: i made a test with revert i think i have understood it.
[17:43:00] Peter Nechaev: but why amending is forbidden?
[17:44:04] jose dim1: if i find the link i will send you, i dont find it again
[17:44:16] Peter Nechaev: that's stupid
[17:44:27] Peter Nechaev: you do with your local copy whatever you want
[17:44:34] Peter Nechaev: reset, amend, whatever
[17:44:47] Peter Nechaev: just don't put this mess in public copy later
[17:44:59] jose dim1: no i mean commit --amend is forbidden in public repo.
[17:45:01] Peter Nechaev: amend does soft reset && commit -c.
[17:45:08] Peter Nechaev: so
[17:45:09] Peter Nechaev: ?
[17:45:30] Peter Nechaev: amend is useful while you're working with local copy
[17:45:40] Peter Nechaev: then you push this commit after to public
[17:46:01] Peter Nechaev: reseting already published commits should be forbidden
[17:46:19] Peter Nechaev: but if you haven't sent it yet, go nuts
[17:46:40] Peter Nechaev: anyway
[17:47:01] Peter Nechaev: don't read too much. You make things complicated
[17:47:21] Peter Nechaev: just go learn C
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
okay, here's a little tip:
Linux has a lazy management. What does it mean? I means, it doesn't store information in file and keeps it in the RAM as long as possible. For example: try to write like 7GB on your usb. The operation will be done in seconds. How? Because it's not actually there. It's still in memory, waiting to be written on disc. That's why you need to run 'sync' afterwards.
So. If you want to test fflush, do the folowing: use one program to write a lot of data in file, then make it wait (for input or something). Don't close the stream and don't flush it. Write another program (or just use cat) to read the data from the file. You'll see, that it's not there. Then do fflush and check file one more time. You'll see the data
[13:56:06] jose dim1: what kind of data can i store in the file? like an array of 10 structs?
[13:58:36] Peter Nechaev: yes. But maybe more than that. Structure is just a combination of different types in one place. Like char = 1 byte, int = 4 byte, struct with char and int members = 5 bytes. 10 structs = 50 bytes."
That amount of data can be written right away.
So maybe you need more. Or maybe not. Just experiment.
[13:59:14] Peter Nechaev: If you can write like 50 MB of data, that would be great.


I'm sorry. I was busy with other project. It was a real mess and I had to spend like 10 hours a day on it.
[22:18:42] Peter Nechaev: 17:
[22:18:54] Peter Nechaev: why didn't you just try it?
[22:19:03] Peter Nechaev: yes, it will be rewritten
[22:19:08] Peter Nechaev: it suppose to be
[22:19:19] Peter Nechaev: You store the entire database in file
[22:19:28] Peter Nechaev: You don't just add some new sections
[22:22:18] Peter Nechaev: wchar:
I used wchar only once. I did a project for an exam in my first year. The project was made for Windows, with WinAPI. I never wrote anything for this api, for this os after it.
[22:22:23] Peter Nechaev: I hopefully never will
[22:22:58] Peter Nechaev: Anyway. It required wide characters. Never seen this in unix-like
[22:23:16] Peter Nechaev: about the ex17
[22:23:30] Peter Nechaev: forget about file operations
[22:23:47] Peter Nechaev: the important thing here is "Heap vs. Stack Allocation"
[22:24:47] Peter Nechaev: Because nobody use C for database management. Nobody use C for text editing
[22:26:22] Peter Nechaev: If you're lucky, you'll never have to use file operations in C.
It wasn't made for this.

 And btw, if you want to save a db into a file, use b mode. It's supposed to be faster
[22:28:47] Peter Nechaev: What exactly didn't you understand in ex18?
[22:29:54] Peter Nechaev: test_sorting is simple realization of standard sort functions.

Peter Nechaev: int Object_init(void *self)
{
// do nothing really
return 1;
}

void Object_destroy(void *self)
{
  <...>
free(obj);
 }
[16:48:06] Peter Nechaev: well, there is another one.
[16:48:16] jose dim1: i dont understand the first bad practice.
[16:49:02] Peter Nechaev: you have to allocate memory yourself, but your ojbect deallocating it automatically
[16:49:08] Peter Nechaev: don't do this
[16:49:27] Peter Nechaev: the function should look like this:
malloc
some_staff
free
[16:50:08] Peter Nechaev: Because if you have a method called (object_destroy), which deallocates memory, you think that object_init will allocate it
and you can forget to run malloc yourself
[16:50:24] Peter Nechaev: and it's a segfault

is it important for me to fully understand ex.19 and to learn it? or can i skip it?
[16:53:16] Peter Nechaev: it's good because it will help you understand how sturctures place in memory.
Like the exercise I gave you last time.
I actually wanted to show you during our next session how you can implement templates in C.
[16:53:54] Peter Nechaev: You should never use this in real life (not classes, nor templates)
[16:54:06] Peter Nechaev: but it's important for you to understand, how it works
[16:54:11] Peter Nechaev: and why it works
[16:54:17] Peter Nechaev: and why you should never do it
[16:54:32] jose dim1: so i need to understand but i will never use it lol?
[16:54:41] Peter Nechaev: right
[16:55:04] jose dim1: if i well understood you never do like ex19 in real life?
[16:55:12] jose dim1: you use C++ instead of doing like ex19?

Peter Nechaev: Yes, never use this.
Just create a monster structure not related with another.
The ex is important, because you will run into lots of problems in C and deep understanding of it will help you solve them.
[16:57:03] Peter Nechaev: like yesterday I run into a segfault and I had no degubber

[16:57:44] Peter Nechaev: And my knowledge helped me to determine stack protection problem
[16:58:13] Peter Nechaev: that's why you should know how this works, how duff's device works etc

 Peter Nechaev: I use (info ...) (warning ...) (debug ...) style and have this in my rc file to color them:
[17:12:50] Peter Nechaev: make_func() {
if [ $# -eq 2 -a "$2" == "dev" ]; then
args=( $1 command=$2 )
else
args=( $@ )
fi
cerr=$(echo -e "\033[1;31m")
cwarn=$(echo -e "\033[1;35m")
cdbg=$(echo -e "\033[1;33m")
cbold=$(echo -e "\033[1;39m")
cend=$(echo -e "\033[0m")
grc make $args | sed -e -e "s%(error)\ (\(.*?\):)%$cerr\1 $cbold\2$cend%g" \
-e "s%(warning)\ (\(.*?\):)%$cwarn\1 $cbold\2$cend%g" \
-e "s%(info)\ (\(.*?\):)%$cbold\1 \2$cend%g" \
-e "s%(debug)\ (\(.*?\):)%$cdbg\1 $cbold\2$cend%g" \
-e "s%failed%$cerr&$cend%g"
}
alias make=make_func





